<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 20: Light Client Architectures | Elementary Bitcoin</title>
    <meta name="description" content="Chapter 20: Light Client Architectures - Electrum protocol, trust models, hybrid approaches">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Elementary Bitcoin">
    <meta property="og:title" content="Chapter 20: Light Client Architectures | Elementary Bitcoin">
    <meta property="og:description" content="Electrum protocol, trust models, hybrid approaches">
    <meta property="og:url" content="https://elementarybitcoin.org/chapters/20-light-clients.html">
    <meta property="og:image" content="https://elementarybitcoin.org/og-image.png">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Chapter 20: Light Client Architectures | Elementary Bitcoin">
    <meta name="twitter:description" content="Electrum protocol, trust models, hybrid approaches">
    <meta name="twitter:image" content="https://elementarybitcoin.org/og-image.png">

    <link rel="stylesheet" href="../style.css">
    <style>
        .trust-model {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 2rem 0;
        }
        .trust-card {
            flex: 1;
            min-width: 200px;
            max-width: 280px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
        }
        .trust-card h4 {
            margin-top: 0;
            border-bottom: 2px solid;
            padding-bottom: 0.5rem;
        }
        .trust-full { border-color: #4caf50; }
        .trust-full h4 { border-color: #4caf50; color: #2e7d32; }
        .trust-medium { border-color: #ff9800; }
        .trust-medium h4 { border-color: #ff9800; color: #e65100; }
        .trust-high { border-color: #f44336; }
        .trust-high h4 { border-color: #f44336; color: #c62828; }
        .architecture-note {
            background: #f5f5f5;
            border-left: 4px solid #1976d2;
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
        }
    </style>
</head>
<body>
    <nav class="chapter-nav">
        <a href="19-compact-filters.html">← Chapter 19: Compact Block Filters</a>
        <a href="../index.html">Index</a>
        <a href="21-node-optimizations.html">Chapter 21: Node Optimizations →</a>
    </nav>

    <main class="chapter">
        <header>
            <p class="chapter-number">Chapter 20</p>
            <h1>Light Client Architectures</h1>
            <p class="chapter-subtitle">From Electrum to Modern Wallet Backends</p>
        </header>

        <section class="introduction">
            <p>
                Not every user can or wants to run a full Bitcoin node. Light clients provide
                a spectrum of trade-offs between resource requirements and trust assumptions.
                Understanding these trade-offs is essential for choosing—or building—appropriate
                wallet infrastructure.
            </p>
            <p>
                This chapter surveys the major light client architectures in use today, from
                the Electrum client-server model to modern approaches combining multiple
                techniques. We analyze each approach's trust model, privacy characteristics,
                and suitability for different use cases.
            </p>
        </section>

        <section>
            <h2>20.1 The Light Client Spectrum</h2>

            <p>
                Light clients exist on a spectrum from "minimal trust, maximal resources" to
                "maximal trust, minimal resources":
            </p>

            <div class="trust-model">
                <div class="trust-card trust-full">
                    <h4>Full Validation</h4>
                    <p><strong>Trust:</strong> None (trustless)</p>
                    <p><strong>Resources:</strong> ~550 GB storage, continuous bandwidth</p>
                    <p><strong>Example:</strong> Bitcoin Core</p>
                </div>

                <div class="trust-card trust-medium">
                    <h4>SPV / Light Node</h4>
                    <p><strong>Trust:</strong> Miners (majority honest)</p>
                    <p><strong>Resources:</strong> ~60 MB headers + filters</p>
                    <p><strong>Example:</strong> Neutrino, BIP-157</p>
                </div>

                <div class="trust-card trust-high">
                    <h4>Server-Dependent</h4>
                    <p><strong>Trust:</strong> Server operator</p>
                    <p><strong>Resources:</strong> Minimal</p>
                    <p><strong>Example:</strong> Electrum (public servers)</p>
                </div>
            </div>

            <div class="definition">
                <p><strong>Definition 20.1</strong> (Light Client)</p>
                <p>
                    A <em>light client</em> is any Bitcoin client that does not independently
                    validate all transactions and blocks. Light clients necessarily trust
                    some external party—miners, servers, or peers—for certain guarantees
                    that full nodes verify independently.
                </p>
            </div>

            <h3>Trust Requirements by Architecture</h3>

            <table class="bitcoin-table">
                <thead>
                    <tr>
                        <th>Architecture</th>
                        <th>Transaction Validity</th>
                        <th>Inclusion Proof</th>
                        <th>Privacy</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Full Node</td>
                        <td>Self-verified</td>
                        <td>Self-verified</td>
                        <td>Perfect</td>
                    </tr>
                    <tr>
                        <td>Pruned Node</td>
                        <td>Self-verified</td>
                        <td>Self-verified</td>
                        <td>Perfect</td>
                    </tr>
                    <tr>
                        <td>BIP-157/158</td>
                        <td>Trust miners</td>
                        <td>Merkle proof</td>
                        <td>Good</td>
                    </tr>
                    <tr>
                        <td>Electrum (personal)</td>
                        <td>Trust miners</td>
                        <td>Server provides</td>
                        <td>Good</td>
                    </tr>
                    <tr>
                        <td>Electrum (public)</td>
                        <td>Trust server + miners</td>
                        <td>Server provides</td>
                        <td>Poor</td>
                    </tr>
                    <tr>
                        <td>Centralized API</td>
                        <td>Trust service</td>
                        <td>Trust service</td>
                        <td>None</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>20.2 The Electrum Protocol</h2>

            <p>
                Electrum, created in 2011, pioneered the client-server model for Bitcoin
                wallets. The Electrum protocol (also called ElectrumX protocol) provides
                a JSON-RPC interface for querying blockchain data.
            </p>

            <h3>Architecture Overview</h3>

            <figure>
                <svg viewBox="0 0 700 350" style="max-width: 700px; margin: 2rem auto; display: block;">
                    <text x="350" y="25" text-anchor="middle" font-size="14" font-weight="bold">
                        Electrum Client-Server Architecture
                    </text>

                    <!-- Bitcoin Network -->
                    <g transform="translate(500, 80)">
                        <ellipse cx="100" cy="80" rx="90" ry="70" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                        <text x="100" y="60" text-anchor="middle" font-size="11" font-weight="bold">Bitcoin</text>
                        <text x="100" y="75" text-anchor="middle" font-size="11" font-weight="bold">P2P Network</text>

                        <!-- Full nodes -->
                        <circle cx="60" cy="100" r="15" fill="#4caf50"/>
                        <text x="60" y="105" text-anchor="middle" font-size="8" fill="white">FN</text>
                        <circle cx="100" cy="115" r="15" fill="#4caf50"/>
                        <text x="100" y="120" text-anchor="middle" font-size="8" fill="white">FN</text>
                        <circle cx="140" cy="100" r="15" fill="#4caf50"/>
                        <text x="140" y="105" text-anchor="middle" font-size="8" fill="white">FN</text>
                    </g>

                    <!-- Electrum Server -->
                    <g transform="translate(250, 100)">
                        <rect x="0" y="0" width="150" height="100" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5"/>
                        <text x="75" y="25" text-anchor="middle" font-size="11" font-weight="bold">Electrum Server</text>
                        <text x="75" y="45" text-anchor="middle" font-size="9">(ElectrumX, Fulcrum)</text>

                        <rect x="10" y="55" width="60" height="35" fill="#bbdefb" stroke="#1976d2" rx="3"/>
                        <text x="40" y="72" text-anchor="middle" font-size="8">Full Node</text>
                        <text x="40" y="82" text-anchor="middle" font-size="8">Backend</text>

                        <rect x="80" y="55" width="60" height="35" fill="#bbdefb" stroke="#1976d2" rx="3"/>
                        <text x="110" y="72" text-anchor="middle" font-size="8">Address</text>
                        <text x="110" y="82" text-anchor="middle" font-size="8">Index</text>
                    </g>

                    <!-- Connection to network -->
                    <line x1="400" y1="150" x2="500" y2="150" stroke="#4caf50" stroke-width="2" marker-end="url(#arrow-gr)"/>
                    <text x="450" y="140" text-anchor="middle" font-size="9">P2P Protocol</text>

                    <!-- Electrum Clients -->
                    <g transform="translate(30, 80)">
                        <rect x="0" y="0" width="100" height="50" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5"/>
                        <text x="50" y="20" text-anchor="middle" font-size="10">Electrum</text>
                        <text x="50" y="35" text-anchor="middle" font-size="10">Wallet</text>
                    </g>

                    <g transform="translate(30, 150)">
                        <rect x="0" y="0" width="100" height="50" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5"/>
                        <text x="50" y="20" text-anchor="middle" font-size="10">Mobile</text>
                        <text x="50" y="35" text-anchor="middle" font-size="10">Wallet</text>
                    </g>

                    <g transform="translate(30, 220)">
                        <rect x="0" y="0" width="100" height="50" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5"/>
                        <text x="50" y="20" text-anchor="middle" font-size="10">Web</text>
                        <text x="50" y="35" text-anchor="middle" font-size="10">Application</text>
                    </g>

                    <!-- Connections to server -->
                    <line x1="130" y1="105" x2="250" y2="130" stroke="#ff9800" stroke-width="2"/>
                    <line x1="130" y1="175" x2="250" y2="155" stroke="#ff9800" stroke-width="2"/>
                    <line x1="130" y1="245" x2="250" y2="180" stroke="#ff9800" stroke-width="2"/>

                    <text x="175" y="120" font-size="9" fill="#e65100">JSON-RPC</text>

                    <!-- Privacy leak indicator -->
                    <g transform="translate(150, 280)">
                        <rect x="0" y="0" width="400" height="50" fill="#ffebee" stroke="#c62828" rx="4"/>
                        <text x="200" y="20" text-anchor="middle" font-size="10" fill="#c62828" font-weight="bold">Privacy Concern:</text>
                        <text x="200" y="35" text-anchor="middle" font-size="9" fill="#c62828">Server learns all wallet addresses, balances, and transaction history</text>
                    </g>

                    <defs>
                        <marker id="arrow-gr" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50"/>
                        </marker>
                    </defs>
                </svg>
                <figcaption>
                    <strong>Figure 20.1</strong> — Electrum architecture: clients connect to
                    servers that maintain an address-indexed database built from a full node.
                    The server sees all client addresses and queries.
                </figcaption>
            </figure>

            <h3>Protocol Methods</h3>

            <div class="definition">
                <p><strong>Definition 20.2</strong> (Core Electrum Methods)</p>
                <table class="bitcoin-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Purpose</th>
                            <th>Privacy Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>blockchain.scripthash.get_history</code></td>
                            <td>Get transaction history for address</td>
                            <td>Reveals address ownership</td>
                        </tr>
                        <tr>
                            <td><code>blockchain.scripthash.get_balance</code></td>
                            <td>Get address balance</td>
                            <td>Reveals address ownership</td>
                        </tr>
                        <tr>
                            <td><code>blockchain.scripthash.listunspent</code></td>
                            <td>Get UTXOs for address</td>
                            <td>Reveals spendable outputs</td>
                        </tr>
                        <tr>
                            <td><code>blockchain.scripthash.subscribe</code></td>
                            <td>Watch address for changes</td>
                            <td>Reveals ongoing interest</td>
                        </tr>
                        <tr>
                            <td><code>blockchain.transaction.broadcast</code></td>
                            <td>Submit transaction</td>
                            <td>Reveals spending intent</td>
                        </tr>
                        <tr>
                            <td><code>blockchain.transaction.get</code></td>
                            <td>Fetch raw transaction</td>
                            <td>Reveals transaction interest</td>
                        </tr>
                        <tr>
                            <td><code>blockchain.headers.subscribe</code></td>
                            <td>Get new block notifications</td>
                            <td>Minimal</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Script Hash Addressing</h3>

            <p>
                Electrum uses script hashes rather than addresses for efficient indexing:
            </p>

            <div class="definition">
                <p><strong>Definition 20.3</strong> (Electrum Script Hash)</p>
                <p>
                    For any scriptPubKey, the Electrum script hash is:
                </p>
                <div class="formula">
                    script_hash = SHA256(scriptPubKey), reversed to little-endian hex
                </div>
                <p>
                    This provides a uniform 32-byte identifier regardless of address type.
                </p>
            </div>

            <div class="example">
                <p><strong>Example 20.1</strong> (Script Hash Computation)</p>
                <p>For a P2WPKH address with scriptPubKey:</p>
                <pre><code>scriptPubKey: OP_0 OP_PUSH_20 <20-byte-hash>
              = 0x0014{hash160}

SHA256(scriptPubKey) = abc123...def456

script_hash (little-endian hex) = 56f4de...23c1ab</code></pre>
            </div>

            <h3>Server Implementations</h3>

            <div class="definition">
                <p><strong>Definition 20.4</strong> (Electrum Server Software)</p>
                <table class="bitcoin-table">
                    <thead>
                        <tr>
                            <th>Software</th>
                            <th>Language</th>
                            <th>Index Size</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ElectrumX</td>
                            <td>Python</td>
                            <td>~50 GB</td>
                            <td>Reference implementation</td>
                        </tr>
                        <tr>
                            <td>Fulcrum</td>
                            <td>C++</td>
                            <td>~100 GB</td>
                            <td>Faster, more features</td>
                        </tr>
                        <tr>
                            <td>electrs</td>
                            <td>Rust</td>
                            <td>~30 GB</td>
                            <td>Efficient, minimal</td>
                        </tr>
                        <tr>
                            <td>Electrum Personal Server</td>
                            <td>Python</td>
                            <td>~0 GB</td>
                            <td>Single-wallet, no index</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section>
            <h2>20.3 Privacy Analysis of Electrum</h2>

            <h3>What the Server Learns</h3>

            <div class="theorem">
                <p><strong>Theorem 20.1</strong> (Electrum Privacy Leakage)</p>
                <p>
                    When a client connects to an Electrum server, the server learns:
                </p>
                <ol>
                    <li>Every address the wallet has ever generated</li>
                    <li>The complete transaction history for those addresses</li>
                    <li>Current balances and unspent outputs</li>
                    <li>Which addresses are monitored in real-time</li>
                    <li>When and what transactions the user broadcasts</li>
                    <li>Client IP address (without Tor)</li>
                    <li>Wallet software and version (from protocol negotiation)</li>
                </ol>
            </div>

            <div class="proof">
                <p><strong>Proof.</strong></p>
                <p>
                    The Electrum protocol requires the client to send scriptPubKey hashes
                    to query address history. The server must store and respond to these
                    queries, necessarily learning the queried addresses. Subscription
                    requests explicitly reveal ongoing interest. Transaction broadcasts
                    reveal spending before the transaction propagates through the P2P network. ∎
                </p>
            </div>

            <h3>Timing Attacks</h3>

            <p>
                Even beyond direct address queries, timing patterns reveal information:
            </p>

            <ul>
                <li><strong>Wallet creation:</strong> Sequential address queries reveal when the wallet was created</li>
                <li><strong>HD derivation:</strong> Query patterns reveal BIP-32 derivation paths</li>
                <li><strong>Change addresses:</strong> Immediate queries after broadcasts reveal change outputs</li>
                <li><strong>Session correlation:</strong> Multiple sessions can be linked by query patterns</li>
            </ul>

            <h3>Mitigations</h3>

            <div class="architecture-note">
                <p><strong>Running Your Own Electrum Server</strong></p>
                <p>
                    The privacy concerns above apply to <em>public</em> Electrum servers.
                    Running your own server (ElectrumX, Fulcrum, electrs) connected to your
                    own full node eliminates third-party privacy leakage, though requires
                    the resources to run both services.
                </p>
            </div>

            <p>Other mitigations:</p>

            <ul>
                <li><strong>Tor:</strong> Hide IP address (but server still sees addresses)</li>
                <li><strong>Multiple servers:</strong> Split queries across servers (partial mitigation)</li>
                <li><strong>Electrum Personal Server:</strong> Minimal server for single wallet</li>
                <li><strong>Gap limit increase:</strong> Query more addresses to add noise</li>
            </ul>
        </section>

        <section>
            <h2>20.4 Esplora and Block Explorer APIs</h2>

            <p>
                Many wallets use HTTP APIs provided by block explorers. While convenient,
                these have significant trust and privacy implications.
            </p>

            <h3>Common API Patterns</h3>

            <div class="definition">
                <p><strong>Definition 20.5</strong> (Block Explorer API Endpoints)</p>
                <p>Typical REST endpoints:</p>
                <pre><code>GET /address/{address}              # Address info
GET /address/{address}/txs          # Transaction history
GET /address/{address}/utxo         # Unspent outputs
GET /tx/{txid}                      # Transaction details
POST /tx                            # Broadcast transaction
GET /block/{hash}                   # Block data
GET /blocks/tip/height              # Current height</code></pre>
            </div>

            <h3>Esplora</h3>

            <p>
                Esplora (by Blockstream) is an open-source block explorer with a well-defined
                API. Many wallets support Esplora-compatible backends.
            </p>

            <div class="example">
                <p><strong>Example 20.2</strong> (Esplora Query)</p>
                <pre><code>// Get UTXOs for address
GET https://blockstream.info/api/address/bc1q.../utxo

Response:
[
  {
    "txid": "abc123...",
    "vout": 0,
    "status": {"confirmed": true, "block_height": 800000},
    "value": 10000
  }
]</code></pre>
            </div>

            <h3>Trust Model</h3>

            <div class="theorem">
                <p><strong>Theorem 20.2</strong> (API Trust Requirements)</p>
                <p>
                    When using a third-party API:
                </p>
                <ul>
                    <li><strong>Availability:</strong> Service can deny access or go offline</li>
                    <li><strong>Integrity:</strong> Service can return false data (balances, history)</li>
                    <li><strong>Privacy:</strong> Service logs all queries with IP addresses</li>
                    <li><strong>Censorship:</strong> Service can refuse to broadcast transactions</li>
                </ul>
                <p>
                    Without independent verification (Merkle proofs, header validation), the
                    client must trust the API operator completely.
                </p>
            </div>

            <h3>Self-Hosted Esplora</h3>

            <p>
                Running your own Esplora instance provides:
            </p>

            <ul>
                <li>Privacy: No third-party sees your queries</li>
                <li>Availability: You control uptime</li>
                <li>Integrity: Backed by your own full node</li>
            </ul>

            <p>
                Requirements: Full node + Esplora indexer (~100 GB additional storage).
            </p>
        </section>

        <section>
            <h2>20.5 Hybrid Approaches</h2>

            <p>
                Modern wallets often combine multiple approaches to optimize for different
                requirements.
            </p>

            <h3>Multi-Backend Wallets</h3>

            <figure>
                <svg viewBox="0 0 650 280" style="max-width: 650px; margin: 2rem auto; display: block;">
                    <text x="325" y="25" text-anchor="middle" font-size="14" font-weight="bold">
                        Hybrid Light Client Architecture
                    </text>

                    <!-- Wallet -->
                    <g transform="translate(250, 50)">
                        <rect x="0" y="0" width="150" height="60" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5"/>
                        <text x="75" y="25" text-anchor="middle" font-size="11" font-weight="bold">Wallet Client</text>
                        <text x="75" y="45" text-anchor="middle" font-size="9">Backend abstraction layer</text>
                    </g>

                    <!-- Backend options -->
                    <g transform="translate(30, 150)">
                        <rect x="0" y="0" width="120" height="70" fill="#e8f5e9" stroke="#4caf50" rx="4"/>
                        <text x="60" y="25" text-anchor="middle" font-size="10" font-weight="bold">Full Node</text>
                        <text x="60" y="45" text-anchor="middle" font-size="9">Bitcoin Core RPC</text>
                        <text x="60" y="60" text-anchor="middle" font-size="8" fill="#666">Best security</text>
                    </g>

                    <g transform="translate(170, 150)">
                        <rect x="0" y="0" width="120" height="70" fill="#e3f2fd" stroke="#1976d2" rx="4"/>
                        <text x="60" y="25" text-anchor="middle" font-size="10" font-weight="bold">Electrum</text>
                        <text x="60" y="45" text-anchor="middle" font-size="9">Personal server</text>
                        <text x="60" y="60" text-anchor="middle" font-size="8" fill="#666">Good privacy</text>
                    </g>

                    <g transform="translate(310, 150)">
                        <rect x="0" y="0" width="120" height="70" fill="#fff3e0" stroke="#ff9800" rx="4"/>
                        <text x="60" y="25" text-anchor="middle" font-size="10" font-weight="bold">Neutrino</text>
                        <text x="60" y="45" text-anchor="middle" font-size="9">BIP-157/158</text>
                        <text x="60" y="60" text-anchor="middle" font-size="8" fill="#666">P2P privacy</text>
                    </g>

                    <g transform="translate(450, 150)">
                        <rect x="0" y="0" width="120" height="70" fill="#ffebee" stroke="#c62828" rx="4"/>
                        <text x="60" y="25" text-anchor="middle" font-size="10" font-weight="bold">Public API</text>
                        <text x="60" y="45" text-anchor="middle" font-size="9">Esplora/Blockstream</text>
                        <text x="60" y="60" text-anchor="middle" font-size="8" fill="#666">Fallback only</text>
                    </g>

                    <!-- Connections -->
                    <line x1="325" y1="110" x2="90" y2="150" stroke="#666" stroke-width="1"/>
                    <line x1="325" y1="110" x2="230" y2="150" stroke="#666" stroke-width="1"/>
                    <line x1="325" y1="110" x2="370" y2="150" stroke="#666" stroke-width="1"/>
                    <line x1="325" y1="110" x2="510" y2="150" stroke="#666" stroke-width="1" stroke-dasharray="4"/>

                    <!-- Priority labels -->
                    <text x="175" y="135" font-size="8" fill="#4caf50">Priority 1</text>
                    <text x="265" y="135" font-size="8" fill="#1976d2">Priority 2</text>
                    <text x="360" y="135" font-size="8" fill="#ff9800">Priority 3</text>
                    <text x="460" y="135" font-size="8" fill="#c62828">Fallback</text>

                    <!-- Note -->
                    <text x="325" y="260" text-anchor="middle" font-size="10" fill="#666">
                        Wallet tries backends in priority order, falling back as needed
                    </text>
                </svg>
                <figcaption>
                    <strong>Figure 20.2</strong> — Hybrid architecture: wallets can support multiple
                    backends with configurable priority, optimizing for security when available
                    and falling back to less private options when necessary.
                </figcaption>
            </figure>

            <h3>Verification Layers</h3>

            <p>
                Even when using a server backend, clients can add verification:
            </p>

            <div class="definition">
                <p><strong>Definition 20.6</strong> (Layered Verification)</p>
                <table class="bitcoin-table">
                    <thead>
                        <tr>
                            <th>Layer</th>
                            <th>Verification</th>
                            <th>Protects Against</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Header chain</td>
                            <td>Validate PoW chain</td>
                            <td>Fake blocks with low work</td>
                        </tr>
                        <tr>
                            <td>Merkle proofs</td>
                            <td>Verify tx inclusion</td>
                            <td>Fabricated transactions</td>
                        </tr>
                        <tr>
                            <td>Filter headers</td>
                            <td>Multi-peer consensus</td>
                            <td>Transaction omission</td>
                        </tr>
                        <tr>
                            <td>Multiple servers</td>
                            <td>Cross-reference responses</td>
                            <td>Single malicious server</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="example">
                <p><strong>Example 20.3</strong> (Verification-Enhanced Electrum)</p>
                <p>
                    A wallet using Electrum can add security by:
                </p>
                <ol>
                    <li>Requesting Merkle proofs for all transactions</li>
                    <li>Maintaining a validated header chain locally</li>
                    <li>Verifying transactions are included in headers</li>
                    <li>Querying multiple Electrum servers for consensus</li>
                </ol>
                <p>
                    This doesn't fix privacy (servers still see addresses) but prevents
                    balance manipulation attacks.
                </p>
            </div>
        </section>

        <section>
            <h2>20.6 The Validation Gap</h2>

            <p>
                The previous sections described how light clients obtain and verify
                <em>inclusion</em> of transactions in blocks. But inclusion is not the same
                as validity. This section examines precisely what a light client cannot
                verify and considers how the gap might be narrowed incrementally.
            </p>

            <h3>What Full Nodes Check</h3>

            <p>
                Recall from Chapter 15 that consensus requires every block to satisfy
                a comprehensive set of rules. A full node verifies all of them; a light
                client verifies almost none. The following table classifies every major
                consensus check by whether a light client can perform it.
            </p>

            <div class="definition">
                <p><strong>Definition 20.8</strong> (Validation Capability Classes)</p>
                <p>
                    We classify consensus checks into four classes based on the data
                    required to verify them:
                </p>
                <ol>
                    <li><strong>Class H</strong> (Header-only): Verifiable from the 80-byte header chain alone.</li>
                    <li><strong>Class T</strong> (Transaction-level): Requires the offending transaction plus its
                        merkle inclusion proof and, in some cases, the spent output data.</li>
                    <li><strong>Class F</strong> (Fraud-provable): Not verifiable by default, but a compact fraud proof
                        can demonstrate a violation using a small witness (typically under 2 KB).</li>
                    <li><strong>Class U</strong> (UTXO-dependent): Requires access to the unspent transaction output
                        set, which light clients do not possess.</li>
                </ol>
            </div>

            <table class="bitcoin-table">
                <thead>
                    <tr>
                        <th>Consensus Rule</th>
                        <th>Class</th>
                        <th>Evidence Required</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Proof-of-work meets difficulty target</td>
                        <td>H</td>
                        <td>Block header (80 bytes)</td>
                    </tr>
                    <tr>
                        <td>Difficulty retarget is correct</td>
                        <td>H</td>
                        <td>Previous 2016 headers</td>
                    </tr>
                    <tr>
                        <td>Timestamp within median-time bounds</td>
                        <td>H</td>
                        <td>Previous 11 headers</td>
                    </tr>
                    <tr>
                        <td>Previous block hash links correctly</td>
                        <td>H</td>
                        <td>Adjacent headers</td>
                    </tr>
                    <tr>
                        <td>Block version meets activation height</td>
                        <td>H</td>
                        <td>Header + height</td>
                    </tr>
                    <tr>
                        <td>Block weight does not exceed limit</td>
                        <td>F</td>
                        <td>SHA-256 midstate proof (BIP 180)</td>
                    </tr>
                    <tr>
                        <td>Coinbase reward does not exceed subsidy + fees</td>
                        <td>F</td>
                        <td>Coinbase transaction + merkle proof</td>
                    </tr>
                    <tr>
                        <td>Coinbase encodes block height (BIP 34)</td>
                        <td>F</td>
                        <td>Coinbase transaction + merkle proof</td>
                    </tr>
                    <tr>
                        <td>Witness commitment present in coinbase</td>
                        <td>F</td>
                        <td>Coinbase transaction + merkle proof</td>
                    </tr>
                    <tr>
                        <td>Transaction signatures are valid</td>
                        <td>T</td>
                        <td>Transaction + merkle proof + spent output scripts</td>
                    </tr>
                    <tr>
                        <td>Locktime and sequence constraints</td>
                        <td>T</td>
                        <td>Transaction + merkle proof + block context</td>
                    </tr>
                    <tr>
                        <td>No duplicate transactions within a block</td>
                        <td>T</td>
                        <td>Two transactions + both merkle proofs</td>
                    </tr>
                    <tr>
                        <td>Script execution succeeds</td>
                        <td>T</td>
                        <td>Transaction + spent output data + Script interpreter</td>
                    </tr>
                    <tr>
                        <td>Inputs reference existing unspent outputs</td>
                        <td>U</td>
                        <td>UTXO set or equivalent commitment</td>
                    </tr>
                    <tr>
                        <td>No cross-block double-spending</td>
                        <td>U</td>
                        <td>UTXO set or equivalent commitment</td>
                    </tr>
                    <tr>
                        <td>Total fees calculated correctly</td>
                        <td>U</td>
                        <td>All transaction inputs (requires UTXO set for input values)</td>
                    </tr>
                </tbody>
            </table>

            <h3>Fraud Proofs: Compact Evidence of Rule Violations</h3>

            <p>
                The Bitcoin whitepaper, in its discussion of simplified payment
                verification, anticipated that full nodes could alert light clients
                when they detect an invalid block. This concept is now called a
                <em>fraud proof</em>: a compact piece of evidence that demonstrates
                a specific consensus violation.
            </p>

            <div class="definition">
                <p><strong>Definition 20.9</strong> (Fraud Proof)</p>
                <p>
                    A <em>fraud proof</em> for a consensus rule <em>R</em> applied to block <em>B</em>
                    is a data structure <em>P</em> such that:
                </p>
                <ol>
                    <li><strong>Completeness:</strong> If <em>B</em> violates <em>R</em>, an honest full node
                        can construct <em>P</em> from block data.</li>
                    <li><strong>Soundness:</strong> If <em>B</em> satisfies <em>R</em>, no adversary can
                        construct a valid <em>P</em>.</li>
                    <li><strong>Compactness:</strong> |<em>P</em>| is significantly smaller than |<em>B</em>|.</li>
                    <li><strong>Verifiability:</strong> A light client holding the header chain can verify
                        <em>P</em> without additional data.</li>
                </ol>
            </div>

            <p>
                BIP 180 specifies a fraud proof for the block weight rule (Class F above).
                The proof works by including SHA-256 midstate data that allows reconstruction
                of the merkle root from partial transaction size information. If the
                reconstructed merkle root matches the header and the computed weight exceeds
                the consensus limit, the proof is valid. The total evidence is approximately
                1&ndash;2 KB, compared to the full block which may be several megabytes.
            </p>

            <p>
                Similar constructions work for other Class F rules. A coinbase inflation
                proof, for instance, requires only the coinbase transaction (typically
                200&ndash;500 bytes) and its merkle inclusion proof (about 11 hashes for
                a block of 2000 transactions). The light client verifies the merkle proof
                against the header it already holds, parses the coinbase outputs, and
                checks that the total does not exceed the known subsidy for that block
                height plus the claimed fee total.
            </p>

            <div class="theorem">
                <p><strong>Theorem 20.3</strong> (Fraud Proof Coverage)</p>
                <p>
                    Given a distribution mechanism for fraud proofs and assuming data
                    availability (that is, block data is accessible to at least one
                    honest full node), the following consensus rules become enforceable
                    by a light client holding only the header chain:
                </p>
                <ul>
                    <li>All Class H rules (verified directly from headers)</li>
                    <li>All Class F rules (verified via compact fraud proofs)</li>
                    <li>All Class T rules (verified via transaction-level fraud proofs,
                        given a Script evaluation capability in the client)</li>
                </ul>
                <p>
                    Class U rules remain unenforceable without either UTXO set
                    commitments in the block header (requiring a consensus change) or
                    a validity proof covering the full state transition.
                </p>
            </div>

            <div class="proof">
                <p><strong>Proof.</strong></p>
                <p>
                    For Class H, the light client performs the check directly from stored
                    headers. For Class F, the fraud proof provides a compact witness linking
                    the violation to the block header via merkle inclusion; the client verifies
                    the merkle path and checks the rule. For Class T, the fraud proof includes
                    the offending transaction, its merkle path, and any referenced output data;
                    the client verifies inclusion and re-executes the relevant check. For Class U,
                    proving that a UTXO does <em>not</em> exist requires enumerating the
                    entire set or referencing a commitment that does not currently exist in
                    Bitcoin's block structure. Without such a commitment, no compact
                    non-existence proof is possible. ∎
                </p>
            </div>

            <h3>The Data Availability Problem</h3>

            <p>
                Fraud proofs assume that block data is available to honest full nodes.
                But a malicious miner could publish a valid header&mdash;one with
                sufficient proof of work&mdash;while withholding the corresponding block
                data. In this scenario:
            </p>

            <ul>
                <li>The light client sees a valid header and accepts the block.</li>
                <li>Full nodes cannot download the block to verify it.</li>
                <li>No fraud proof can be generated because the evidence is hidden.</li>
            </ul>

            <p>
                This is the <em>data availability problem</em>. Solutions proposed in
                other systems include data availability sampling, where light clients
                request random fragments of the block and use erasure coding to detect
                withholding. Bitcoin does not currently implement such a mechanism.
            </p>

            <h3>Compact Clients: Header Distribution via Relay Networks</h3>

            <p>
                A practical obstacle for light clients is obtaining block headers
                reliably. Traditional SPV clients connect to the Bitcoin peer-to-peer
                network directly, which exposes them to eclipse attacks where all
                connected peers are controlled by an adversary.
            </p>

            <p>
                An alternative approach distributes headers through a separate relay
                network. Full nodes acting as publishers serialize each new block header
                and broadcast it through the relay layer. Light clients subscribe to
                multiple independent publishers and verify the header chain locally.
            </p>

            <div class="definition">
                <p><strong>Definition 20.10</strong> (Compact Client)</p>
                <p>
                    A <em>compact client</em> is a light client that:
                </p>
                <ol>
                    <li>Receives block headers from one or more publishers via a relay network,
                        rather than from the Bitcoin P2P network directly.</li>
                    <li>Validates the header chain (proof of work, difficulty, timestamps).</li>
                    <li>Optionally subscribes to fraud proof events from multiple independent
                        full nodes.</li>
                    <li>Alerts the user when publishers disagree on the chain tip, indicating
                        a possible chain split or eclipse attack.</li>
                </ol>
            </div>

            <p>
                This architecture offers improved eclipse resistance compared to
                traditional SPV. An attacker must compromise all relay endpoints
                simultaneously rather than surrounding a single node in the P2P
                network. Publisher identity is cryptographically fixed, so the client
                knows exactly which full nodes it is trusting and can select publishers
                operated by independent parties.
            </p>

            <h3>Incremental Verification Tiers</h3>

            <p>
                Combining the classification above with the compact client architecture
                yields a natural progression from minimal to near-full verification:
            </p>

            <table class="bitcoin-table">
                <thead>
                    <tr>
                        <th>Tier</th>
                        <th>What the Client Verifies</th>
                        <th>Trust Assumption</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>0: Header chain</td>
                        <td>PoW, difficulty, timestamps, chain linkage (Class H)</td>
                        <td>Longest valid-work chain is honest</td>
                    </tr>
                    <tr>
                        <td>1: Block-level fraud proofs</td>
                        <td>Block weight, coinbase inflation, BIP 34/141 commitments (Class F)</td>
                        <td>At least one honest publisher relays fraud proofs</td>
                    </tr>
                    <tr>
                        <td>2: Transaction-level fraud proofs</td>
                        <td>Signatures, timelocks, script execution (Class T)</td>
                        <td>Same as Tier 1, plus client has Script evaluation</td>
                    </tr>
                    <tr>
                        <td>3: UTXO verification</td>
                        <td>Input existence, cross-block double-spends, fee totals (Class U)</td>
                        <td>Requires UTXO commitments (consensus change) or validity proofs</td>
                    </tr>
                </tbody>
            </table>

            <p>
                Each tier strictly reduces the trust surface. A Tier 0 client trusts
                that the majority of mining hash rate produces valid blocks. A Tier 1
                client only trusts that miners do not violate the specific Class F rules
                <em>and</em> that no honest full node detects the violation, which is
                a strictly weaker assumption. The progression continues until Tier 3,
                which approaches full node security but depends on infrastructure
                that does not yet exist in Bitcoin's consensus layer.
            </p>

            <div class="architecture-note">
                <p><strong>Honest Assessment</strong></p>
                <p>
                    Even at Tier 2, a light client with fraud proofs is not equivalent
                    to a full node. The fundamental difference is epistemic: a full node
                    has <em>positive knowledge</em> that every rule was satisfied, while a
                    light client with fraud proofs has only the <em>absence of evidence</em>
                    that any rule was violated. This distinction, emphasized by Bitcoin
                    Core developers, is real and irreducible. The value of the tiered
                    approach is not that it replaces full validation, but that it honestly
                    quantifies what can and cannot be verified at each resource level.
                </p>
            </div>
        </section>

        <section>
            <h2>20.7 Wallet Architectures in Practice</h2>

            <h3>Desktop Wallets</h3>

            <table class="bitcoin-table">
                <thead>
                    <tr>
                        <th>Wallet</th>
                        <th>Backend</th>
                        <th>Privacy</th>
                        <th>Verification</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Bitcoin Core</td>
                        <td>Built-in full node</td>
                        <td>Perfect</td>
                        <td>Full</td>
                    </tr>
                    <tr>
                        <td>Electrum</td>
                        <td>Electrum servers</td>
                        <td>Configurable</td>
                        <td>Merkle proofs</td>
                    </tr>
                    <tr>
                        <td>Sparrow</td>
                        <td>Core/Electrum/Public</td>
                        <td>Configurable</td>
                        <td>Merkle proofs</td>
                    </tr>
                    <tr>
                        <td>Wasabi</td>
                        <td>BIP-157/158</td>
                        <td>Good</td>
                        <td>Filters + headers</td>
                    </tr>
                </tbody>
            </table>

            <h3>Mobile Wallets</h3>

            <table class="bitcoin-table">
                <thead>
                    <tr>
                        <th>Wallet</th>
                        <th>Backend</th>
                        <th>Privacy</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>BlueWallet</td>
                        <td>Electrum/own server</td>
                        <td>Configurable</td>
                        <td>Can use own server</td>
                    </tr>
                    <tr>
                        <td>Blockstream Green</td>
                        <td>Blockstream servers</td>
                        <td>Trust Blockstream</td>
                        <td>Multisig option</td>
                    </tr>
                    <tr>
                        <td>Phoenix (LN)</td>
                        <td>ACINQ servers</td>
                        <td>Trust ACINQ</td>
                        <td>Lightning-focused</td>
                    </tr>
                    <tr>
                        <td>Breez (LN)</td>
                        <td>Neutrino</td>
                        <td>Good</td>
                        <td>BIP-157/158</td>
                    </tr>
                </tbody>
            </table>

            <h3>Hardware Wallet Integration</h3>

            <p>
                Hardware wallets (Ledger, Trezor, Coldcard) are <em>signing devices</em>,
                not full wallets. They require a software companion for blockchain queries:
            </p>

            <ul>
                <li><strong>Vendor software:</strong> Ledger Live, Trezor Suite (use vendor servers)</li>
                <li><strong>Third-party wallets:</strong> Electrum, Sparrow (configurable backend)</li>
                <li><strong>Best practice:</strong> Use hardware wallet with personal server backend</li>
            </ul>
        </section>

        <section>
            <h2>20.8 Choosing an Architecture</h2>

            <h3>Decision Framework</h3>

            <div class="definition">
                <p><strong>Definition 20.11</strong> (Architecture Selection Criteria)</p>
                <p>Consider these factors when choosing a light client architecture:</p>
                <ol>
                    <li><strong>Privacy requirements:</strong> Who can see your addresses?</li>
                    <li><strong>Trust requirements:</strong> What can a malicious server do?</li>
                    <li><strong>Resource constraints:</strong> Storage, bandwidth, always-online?</li>
                    <li><strong>Use case:</strong> Savings, spending, Lightning, business?</li>
                    <li><strong>Technical ability:</strong> Can you run your own infrastructure?</li>
                </ol>
            </div>

            <h3>Recommendations by Use Case</h3>

            <table class="bitcoin-table">
                <thead>
                    <tr>
                        <th>Use Case</th>
                        <th>Recommended</th>
                        <th>Rationale</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Long-term savings</td>
                        <td>Full node + hardware wallet</td>
                        <td>Maximum security for large amounts</td>
                    </tr>
                    <tr>
                        <td>Privacy-focused</td>
                        <td>Full node or personal Electrum</td>
                        <td>No third-party sees addresses</td>
                    </tr>
                    <tr>
                        <td>Mobile spending</td>
                        <td>Wallet with own server</td>
                        <td>Balance convenience and privacy</td>
                    </tr>
                    <tr>
                        <td>Lightning node</td>
                        <td>Full node or Neutrino</td>
                        <td>Need to monitor channels</td>
                    </tr>
                    <tr>
                        <td>Casual/learning</td>
                        <td>Any reputable wallet</td>
                        <td>Convenience acceptable for small amounts</td>
                    </tr>
                    <tr>
                        <td>Business/exchange</td>
                        <td>Full node required</td>
                        <td>Cannot trust third parties</td>
                    </tr>
                </tbody>
            </table>

            <h3>The Path to Self-Sovereignty</h3>

            <div class="architecture-note">
                <p><strong>Progressive Decentralization</strong></p>
                <p>
                    Users often progress through trust levels as they gain experience:
                </p>
                <ol>
                    <li>Start with convenient public server wallet</li>
                    <li>Add Tor for IP privacy</li>
                    <li>Run personal Electrum server</li>
                    <li>Eventually run full Bitcoin Core node</li>
                </ol>
                <p>
                    This progression reflects increasing value stored and deepening understanding.
                </p>
            </div>
        </section>

        <section class="exercises">
            <h2>Exercises</h2>

            <div class="exercise">
                <p><strong>Exercise 20.1</strong></p>
                <p>
                    Set up electrs (Rust Electrum server) connected to Bitcoin Core in
                    regtest mode. Query it using the Electrum protocol and observe the
                    raw JSON-RPC messages.
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.2</strong></p>
                <p>
                    Compare the bandwidth requirements for syncing a 100-address wallet
                    from genesis using: (a) full node, (b) BIP-157/158, (c) Electrum
                    server queries. Assume average block has 2500 transactions.
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.3</strong></p>
                <p>
                    Design an attack where a malicious Electrum server profits by lying
                    about transaction confirmations. What verification would detect this?
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.4</strong></p>
                <p>
                    Explain why running an Electrum server over Tor still leaks privacy
                    to the server operator, while BIP-157/158 over Tor provides meaningful
                    privacy even against the peer.
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.5</strong></p>
                <p>
                    A wallet queries three Electrum servers and receives conflicting
                    balance information. Design a protocol to identify which server(s)
                    are lying using Merkle proofs.
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.6</strong></p>
                <p>
                    Calculate the storage requirements to run: (a) Bitcoin Core, (b) pruned
                    Bitcoin Core, (c) Bitcoin Core + ElectrumX, (d) Bitcoin Core + Fulcrum.
                    Which setups can run on a Raspberry Pi with 1TB storage?
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.7</strong></p>
                <p>
                    Construct a coinbase inflation fraud proof for a block at height
                    840,000 (post-halving, subsidy = 3.125 BTC). Specify exactly what
                    data the proof must contain, how the light client verifies the merkle
                    inclusion, and what check it performs on the coinbase outputs.
                    What information is the light client still missing to verify that
                    the claimed fee total is correct?
                </p>
            </div>

            <div class="exercise">
                <p><strong>Exercise 20.8</strong></p>
                <p>
                    A compact client subscribes to three independent header publishers.
                    Two publishers report block hash <em>A</em> at height <em>n</em>, while
                    the third reports a different hash <em>B</em> at the same height.
                    Describe the possible causes (chain split, eclipse attack on one publisher,
                    stale block) and design a decision procedure for the client.
                </p>
            </div>
        </section>

        <section class="summary">
            <h2>Chapter Summary</h2>

            <ul>
                <li>
                    Light clients exist on a spectrum from trustless (full node) to fully
                    trusted (centralized API), with various trade-offs in between.
                </li>
                <li>
                    Electrum's client-server model provides efficient address queries but
                    reveals all wallet addresses to the server.
                </li>
                <li>
                    Running your own Electrum server eliminates third-party privacy leakage
                    but requires additional infrastructure.
                </li>
                <li>
                    Block explorer APIs are convenient but provide no verification and
                    complete privacy loss to the operator.
                </li>
                <li>
                    Hybrid approaches combine multiple backends with verification layers
                    to optimize for different requirements.
                </li>
                <li>
                    Consensus rules can be classified by what data is needed to verify them:
                    header-only (Class H), transaction-level (Class T), fraud-provable
                    (Class F), and UTXO-dependent (Class U). Light clients can incrementally
                    close the validation gap by progressing through verification tiers.
                </li>
                <li>
                    Fraud proofs enable compact evidence of consensus violations, but depend
                    on data availability and provide negative assurance (absence of alerts)
                    rather than the positive assurance of full validation.
                </li>
                <li>
                    The best architecture depends on your specific privacy, security, and
                    resource requirements&mdash;there is no one-size-fits-all solution.
                </li>
            </ul>
        </section>

        <nav class="chapter-nav">
            <a href="19-compact-filters.html">← Chapter 19: Compact Block Filters</a>
            <a href="../index.html">Index</a>
            <a href="21-node-optimizations.html">Chapter 21: Node Optimizations →</a>
        </nav>
    </main>

    <footer>
        <p>Elementary Bitcoin — Volume III: Scaling and Verification</p>
    </footer>
</body>
</html>
